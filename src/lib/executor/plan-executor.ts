import { Agent } from '../agent';
import { OllamaClient } from '../llm/ollama-client';
import { registerTools } from '../tools';
import path from 'path';
import fs from 'fs/promises';

/**
 * Custom exceptions for plan execution
 */
export class PlanParseError extends Error {
  constructor(
    public readonly planFile: string,
    public readonly reason: string
  ) {
    super(`Failed to parse plan from ${planFile}: ${reason}`);
    this.name = 'PlanParseError';
    Error.captureStackTrace(this, this.constructor);
  }
}

export class CheckpointValidationError extends Error {
  constructor(
    public readonly checkpoint: string,
    public readonly validationDetails: string
  ) {
    super(`Checkpoint "${checkpoint}" validation failed: ${validationDetails}`);
    this.name = 'CheckpointValidationError';
    Error.captureStackTrace(this, this.constructor);
  }
}

export class PlanExecutionError extends Error {
  constructor(
    public readonly planFile: string,
    public readonly step: string,
    public readonly originalError: Error
  ) {
    super(`Plan execution failed at step "${step}" in ${planFile}: ${originalError.message}`);
    this.name = 'PlanExecutionError';
    Error.captureStackTrace(this, this.constructor);
  }
}

export class RollbackError extends Error {
  constructor(
    public readonly checkpoint: string,
    public readonly reason: string
  ) {
    super(`Rollback to checkpoint "${checkpoint}" failed: ${reason}`);
    this.name = 'RollbackError';
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * Parsed checkpoint from a plan
 */
export interface Checkpoint {
  id: string;
  description: string;
  verificationMethod: string;
  completed: boolean;
}

/**
 * Implementation step from a plan
 */
export interface ImplementationStep {
  phase: string;
  stepNumber: string;
  description: string;
  filesAffected: string[];
  keyDetails: string;
  errorHandling: string;
  completed: boolean;
}

/**
 * Parsed plan structure
 */
export interface ParsedPlan {
  title: string;
  domain: string;
  complexity: string;
  context: string;
  requirements: string;
  architecture: string;
  steps: ImplementationStep[];
  checkpoints: Checkpoint[];
  errorHandling: string;
  testingRequirements: string;
  rollbackStrategy: string;
}

/**
 * Execution result
 */
export interface ExecutionResult {
  planFile: string;
  success: boolean;
  completedSteps: string[];
  failedStep?: string;
  error?: Error;
  executionTime: number;
  checkpointsReached: string[];
}

/**
 * Executes implementation plans generated by specialized agents
 */
export class PlanExecutor {
  private agent: Agent;
  public llm: OllamaClient;
  private executionLog: string[];

  constructor(llm: OllamaClient) {
    this.llm = llm;
    
    // Create an executor agent with all tools
    this.agent = new Agent(
      {
        name: 'plan-executor',
        role: 'admin',
        systemPrompt: this.buildSystemPrompt(),
      },
      llm,
      20 // Higher max iterations for complex tasks
    );

    // Register all available tools
    registerTools(this.agent);
    
    this.executionLog = [];
  }

  /**
   * Build system prompt for the executor agent
   */
  private buildSystemPrompt(): string {
    return `You are a plan execution agent. Your role is to:

1. Read and understand implementation plans
2. Execute each step of the plan precisely
3. Verify checkpoints before proceeding
4. Handle errors gracefully with rollback capability
5. Write production-ready code with:
   - No placeholders (no TODO, FIXME, or ...)
   - Complete error handling with custom exception classes
   - Full type safety
   - Comprehensive testing

You have access to tools:
- readFile: Read file contents
- writeFile: Write/create files
- searchFiles: Find files by pattern
- blobSearch: Search file contents
- bashExec: Execute shell commands

Follow the plan's implementation steps exactly. At each checkpoint, verify your work before continuing.
If any step fails, use the rollback strategy defined in the plan.`;
  }

  /**
   * Execute an implementation plan
   */
  async executePlan(
    planFile: string,
    dryRun: boolean = false
  ): Promise<ExecutionResult> {
    const startTime = Date.now();
    const completedSteps: string[] = [];
    const checkpointsReached: string[] = [];

    try {
      this.log(`Starting plan execution: ${planFile}`);
      
      // Parse the plan
      const plan = await this.parsePlan(planFile);
      this.log(`Parsed plan: ${plan.title} (${plan.complexity} complexity)`);

      if (dryRun) {
        this.log('DRY RUN MODE - No actual changes will be made');
        return {
          planFile,
          success: true,
          completedSteps: plan.steps.map(s => s.stepNumber),
          executionTime: (Date.now() - startTime) / 1000,
          checkpointsReached: plan.checkpoints.map(c => c.id),
        };
      }

      // Load the plan content for the agent
      const planContent = await fs.readFile(planFile, 'utf-8');

      // Execute each phase and step
      for (const step of plan.steps) {
        this.log(`Executing step ${step.stepNumber}: ${step.description}`);

        try {
          await this.executeStep(step, planContent);
          completedSteps.push(step.stepNumber);
          step.completed = true;
        } catch (error: any) {
          throw new PlanExecutionError(
            planFile,
            step.stepNumber,
            error
          );
        }

        // Check if we've reached a checkpoint
        const checkpoint = this.findCheckpointForStep(step.stepNumber, plan.checkpoints);
        if (checkpoint) {
          this.log(`Reached checkpoint: ${checkpoint.id}`);
          
          const validationResult = await this.validateCheckpoint(checkpoint, planContent);
          if (!validationResult.success) {
            throw new CheckpointValidationError(
              checkpoint.id,
              validationResult.details
            );
          }
          
          checkpointsReached.push(checkpoint.id);
          checkpoint.completed = true;
        }
      }

      this.log('Plan execution completed successfully');

      return {
        planFile,
        success: true,
        completedSteps,
        executionTime: (Date.now() - startTime) / 1000,
        checkpointsReached,
      };

    } catch (error: any) {
      this.log(`Plan execution failed: ${error.message}`);

      return {
        planFile,
        success: false,
        completedSteps,
        failedStep: error instanceof PlanExecutionError ? error.step : 'unknown',
        error,
        executionTime: (Date.now() - startTime) / 1000,
        checkpointsReached,
      };
    }
  }

  /**
   * Execute a single implementation step
   */
  private async executeStep(
    step: ImplementationStep,
    planContext: string
  ): Promise<void> {
    const prompt = `
Execute the following implementation step from the plan:

**Step ${step.stepNumber}: ${step.description}**

Phase: ${step.phase}
Files affected: ${step.filesAffected.join(', ')}

Key implementation details:
${step.keyDetails}

Error handling requirements:
${step.errorHandling}

Plan context:
${planContext}

Please implement this step completely. Remember:
- No placeholders or TODOs
- Complete error handling
- Full type safety
- Ready for production

Execute the necessary tool calls to complete this step.
`;

    await this.agent.run(prompt);
  }

  /**
   * Validate that a checkpoint has been properly completed
   */
  private async validateCheckpoint(
    checkpoint: Checkpoint,
    planContext: string
  ): Promise<{ success: boolean; details: string }> {
    const prompt = `
Validate the following checkpoint:

**Checkpoint: ${checkpoint.description}**

Verification method: ${checkpoint.verificationMethod}

Plan context:
${planContext}

Please verify this checkpoint by:
1. Checking that all required files exist and are correct
2. Running any necessary tests
3. Validating the implementation meets requirements

Respond with:
- "CHECKPOINT VALID" if successful
- "CHECKPOINT INVALID: <reason>" if there are issues
`;

    const response = await this.agent.run(prompt);

    if (response.includes('CHECKPOINT VALID')) {
      return { success: true, details: 'Validation passed' };
    }

    const match = response.match(/CHECKPOINT INVALID:\s*(.+)/i);
    const reason = match ? match[1] : 'Unknown validation failure';

    return { success: false, details: reason };
  }

  /**
   * Find checkpoint associated with a step
   */
  private findCheckpointForStep(
    stepNumber: string,
    checkpoints: Checkpoint[]
  ): Checkpoint | null {
    // Simple heuristic: checkpoint numbers often match step phases
    // e.g., Step 1.3 completes at Checkpoint 1
    const phase = stepNumber.split('.')[0];
    return checkpoints.find(c => c.id.includes(phase)) || null;
  }

  /**
   * Parse implementation plan from markdown file
   */
  private async parsePlan(planFile: string): Promise<ParsedPlan> {
    try {
      const content = await fs.readFile(planFile, 'utf-8');
      
      const plan: ParsedPlan = {
        title: this.extractSection(content, /^#\s+(.+)$/m),
        domain: this.extractField(content, 'Domain'),
        complexity: this.extractField(content, 'Complexity'),
        context: this.extractSection(content, /## Context Summary([\s\S]*?)##/),
        requirements: this.extractSection(content, /## Requirements Analysis([\s\S]*?)##/),
        architecture: this.extractSection(content, /## Architecture & Design([\s\S]*?)##/),
        steps: this.parseSteps(content),
        checkpoints: this.parseCheckpoints(content),
        errorHandling: this.extractSection(content, /## Error Handling Strategy([\s\S]*?)##/),
        testingRequirements: this.extractSection(content, /## Testing Requirements([\s\S]*?)##/),
        rollbackStrategy: this.extractSection(content, /## Rollback Strategy([\s\S]*?)##/),
      };

      if (!plan.title || plan.steps.length === 0) {
        throw new PlanParseError(
          planFile,
          'Missing required sections (title or implementation steps)'
        );
      }

      return plan;
    } catch (error: any) {
      throw new PlanParseError(planFile, error.message);
    }
  }

  /**
   * Extract a section from markdown content
   */
  private extractSection(content: string, regex: RegExp): string {
    const match = content.match(regex);
    return match ? match[1]?.trim() || '' : '';
  }

  /**
   * Extract a field value from markdown metadata
   */
  private extractField(content: string, fieldName: string): string {
    const regex = new RegExp(`\\*\\*${fieldName}:\\*\\*\\s*(.+)`, 'i');
    const match = content.match(regex);
    return match ? match[1].trim() : '';
  }

  /**
   * Parse implementation steps from plan
   */
  private parseSteps(content: string): ImplementationStep[] {
    const steps: ImplementationStep[] = [];
    const stepRegex = /###?\s+(?:Step\s+)?(\d+(?:\.\d+)?)[:\s]+(.+)/gi;
    
    let match: RegExpExecArray | null;
    while ((match = stepRegex.exec(content)) !== null) {
      steps.push({
        phase: match[1].split('.')[0],
        stepNumber: match[1],
        description: match[2].trim(),
        filesAffected: [],
        keyDetails: '',
        errorHandling: '',
        completed: false,
      });
    }

    return steps;
  }

  /**
   * Parse checkpoints from plan
   */
  private parseCheckpoints(content: string): Checkpoint[] {
    const checkpoints: Checkpoint[] = [];
    const checkpointRegex = /- \[ \] Checkpoint (\d+):\s*(.+?)\s*-\s*(.+)/gi;
    
    let match: RegExpExecArray | null;
    while ((match = checkpointRegex.exec(content)) !== null) {
      checkpoints.push({
        id: `checkpoint-${match[1]}`,
        description: match[2].trim(),
        verificationMethod: match[3].trim(),
        completed: false,
      });
    }

    return checkpoints;
  }

  /**
   * Log execution events
   */
  private log(message: string): void {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}`;
    this.executionLog.push(logEntry);
    console.log(logEntry);
  }

  /**
   * Get execution log
   */
  getExecutionLog(): string[] {
    return [...this.executionLog];
  }

  /**
   * Clear execution log
   */
  clearLog(): void {
    this.executionLog = [];
  }
}
